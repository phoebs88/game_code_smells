
@inproceedings{fard_jsnose:_2013,
	title = {{JSNOSE}: Detecting {JavaScript} Code Smells},
	doi = {10.1109/SCAM.2013.6648192},
	shorttitle = {{JSNOSE}},
	abstract = {{JavaScript} is a powerful and flexible prototype-based scripting language that is increasingly used by developers to create interactive web applications. The language is interpreted, dynamic, weakly-typed, and has first-class functions. In addition, it interacts with other web languages such as {CSS} and {HTML} at runtime. All these characteristics make {JavaScript} code particularly error-prone and challenging to write and maintain. Code smells are patterns in the source code that can adversely influence program comprehension and maintainability of the program in the long term. We propose a set of 13 {JavaScript} code smells, collected from various developer resources. We present a {JavaScript} code smell detection technique called {JSNOSE}. Our metric-based approach combines static and dynamic analysis to detect smells in client-side code. This automated technique can help developers to spot code that could benefit from refactoring. We evaluate the smell finding capabilities of our technique through an empirical study. By analyzing 11 web applications, we investigate which smells detected by {JSNOSE} are more prevalent.},
	eventtitle = {2013 {IEEE} 13th International Working Conference on Source Code Analysis and Manipulation ({SCAM})},
	pages = {116--125},
	booktitle = {2013 {IEEE} 13th International Working Conference on Source Code Analysis and Manipulation ({SCAM})},
	author = {Fard, A. M. and Mesbah, A.},
	date = {2013-09},
	keywords = {Cascading style sheets, code smell, Conferences, {CSS} languages, {HTML}, {HTML} languages, interactive Web applications, Internet, Java, {JavaScript}, {JavaScript} code smells detection technique, {JSNOSE} technique, Measurement, program debugging, prototype-based scripting language, Prototypes, Reactive power, refactoring, Runtime, smell detection, web applications},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\8TMX5CY7\\6648192.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\HXKWFRIQ\\Fard and Mesbah - 2013 - JSNOSE Detecting JavaScript Code Smells.pdf:application/pdf}
}

@inproceedings{parnin_catalogue_2008,
	location = {New York, {NY}, {USA}},
	title = {A Catalogue of Lightweight Visualizations to Support Code Smell Inspection},
	isbn = {978-1-60558-112-5},
	url = {http://doi.acm.org/10.1145/1409720.1409733},
	doi = {10.1145/1409720.1409733},
	series = {{SoftVis} '08},
	abstract = {Loading...},
	pages = {77--86},
	booktitle = {Proceedings of the 4th {ACM} Symposium on Software Visualization},
	publisher = {{ACM}},
	author = {Parnin, Chris and Görg, Carsten and Nnadi, Ogechi},
	urldate = {2019-07-03},
	date = {2008},
	note = {event-place: Ammersee, Germany},
	keywords = {refactoring, code inspection, code smells, lightweight visualization},
	file = {ACM Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\VAP6C36T\\Parnin et al. - 2008 - A Catalogue of Lightweight Visualizations to Suppo.pdf:application/pdf}
}

@inproceedings{saboury_empirical_2017,
	title = {An empirical study of code smells in {JavaScript} projects},
	doi = {10.1109/SANER.2017.7884630},
	abstract = {{JavaScript} is a powerful scripting programming language that has gained a lot of attention this past decade. Initially used exclusively for client-side web development, it has evolved to become one of the most popular programming languages, with developers now using it for both client-side and server-side application development. Similar to applications written in other programming languages, {JavaScript} applications contain code smells, which are poor design choices that can negatively impact the quality of an application. In this paper, we investigate code smells in {JavaScript} server-side applications with the aim to understand how they impact the fault-proneness of applications. We detect 12 types of code smells in 537 releases of five popular {JavaScript} applications (i.e., express, grunt, bower, less.js, and request) and perform survival analysis, comparing the time until a fault occurrence, in files containing code smells and files without code smells. Results show that (1) on average, files without code smells have hazard rates 65\% lower than files with code smells. (2) Among the studied smells, “Variable Re-assign” and “Assignment In Conditional statements” code smells have the highest hazard rates. Additionally, we conduct a survey with 1,484 {JavaScript} developers, to understand the perception of developers towards our studied code smells. We found that developers consider “Nested Callbacks”, “Variable Re-assign” and “Long Parameter List” code smells to be serious design problems that hinder the maintainability and reliability of applications. This assessment is in line with the findings of our quantitative analysis. Overall, code smells affect negatively the quality of {JavaScript} applications and developers should consider tracking and removing them early on before the release of applications to the public.},
	eventtitle = {2017 {IEEE} 24th International Conference on Software Analysis, Evolution and Reengineering ({SANER})},
	pages = {294--305},
	booktitle = {2017 {IEEE} 24th International Conference on Software Analysis, Evolution and Reengineering ({SANER})},
	author = {Saboury, A. and Musavi, P. and Khomh, F. and Antoniol, G.},
	date = {2017-02},
	keywords = {Internet, Java, Reactive power, application fault-proneness, assignment in conditional statements code smells, client-side Web development, code smell empirical study, Computer languages, Context, Fault diagnosis, fault occurrence, Hazards, {JavaScript} projects, {JavaScript} server-side applications, long parameter list code smells, nested callback code smells, Object oriented programming, programming languages, scripting programming language, server-side application development, source code (software), survival analysis, variable reassign code smells},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\ETZURWZJ\\7884630.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\SBBZEP9L\\Saboury et al. - 2017 - An empirical study of code smells in JavaScript pr.pdf:application/pdf}
}

@article{fontana_preliminary_nodate,
	title = {Preliminary Catalogue of Anti-pattern and Code Smell False Positives},
	pages = {28},
	author = {Fontana, Francesca Arcelli and Dietrich, Jens and Walter, Bartosz and Yamashita, Aiko and Zanoni, Marco},
	langid = {english},
	file = {Fontana et al. - Preliminary Catalogue of Anti-pattern and Code Sme.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\YZWKPXMS\\Fontana et al. - Preliminary Catalogue of Anti-pattern and Code Sme.pdf:application/pdf}
}

@inproceedings{yoshida_revisiting_2016,
	title = {Revisiting the relationship between code smells and refactoring},
	doi = {10.1109/ICPC.2016.7503738},
	abstract = {Refactoring is a critical technique in evolving software systems. Martin Fowler presented a catalogue of refactoring patterns that defines a list of code smells and their corresponding refactoring patterns. This list aimed at supporting programmers in finding suitable refactoring patterns that remove code smells from their systems. However, a recent empirical study by Bavota et al. shows that refactoring rarely removes code smells which do not align with Fowler's catalog. To bridge the gap between them, we revisit the relationship between code smells and refactorings. In this study, we investigate whether developers apply appropriate refactoring patterns to fix code smells in three open source software systems.},
	eventtitle = {2016 {IEEE} 24th International Conference on Program Comprehension ({ICPC})},
	pages = {1--4},
	booktitle = {2016 {IEEE} 24th International Conference on Program Comprehension ({ICPC})},
	author = {Yoshida, N. and Saika, T. and Choi, E. and Ouni, A. and Inoue, K.},
	date = {2016-05},
	keywords = {code smells, source code (software), Bridges, Computer bugs, Couplings, Data mining, Feature extraction, object-oriented methods, Open source software, open source software systems, refactoring patterns, software maintenance, Surgery},
	file = {IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\BVIWNL5A\\Yoshida et al. - 2016 - Revisiting the relationship between code smells an.pdf:application/pdf;Toward a Catalogue of Architectural Bad Smells.pdf:H\:\\code smells paper\\Toward a Catalogue of Architectural Bad Smells.pdf:application/pdf}
}

@misc{noauthor_notitle_nodate,
	file = {Code_smells_as_system-level_indicators_o.pdf:H\:\\code smells paper\\code smells and mainatainability\\Code_smells_as_system-level_indicators_o.pdf:application/pdf;Competitive Coevolutionary Code-Smells Detection.pdf:H\:\\code smells paper\\code smells and mainatainability\\Competitive Coevolutionary Code-Smells Detection.pdf:application/pdf;Detecting Bad Smells in Source Code using change history information.pdf:H\:\\code smells paper\\code smells and mainatainability\\Detecting Bad Smells in Source Code using change history information.pdf:application/pdf;Evaluating the Lifespan of Code Smells using Software Repository Mining.pdf:H\:\\code smells paper\\code smells and mainatainability\\Evaluating the Lifespan of Code Smells using Software Repository Mining.pdf:application/pdf;Mining Version Histories for Detecting Code Smells.pdf:H\:\\code smells paper\\code smells and mainatainability\\Mining Version Histories for Detecting Code Smells.pdf:application/pdf;Subjective evaluation of software evolvability using code smells.pdf:H\:\\code smells paper\\code smells and mainatainability\\Subjective evaluation of software evolvability using code smells.pdf:application/pdf}
}

@article{cruz_catalog_2019,
	title = {Catalog of energy patterns for mobile applications},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-019-09682-0},
	doi = {10.1007/s10664-019-09682-0},
	abstract = {Software engineers make use of design patterns for reasons that range from performance to code comprehensibility. Several design patterns capturing the body of knowledge of best practices have been proposed in the past, namely creational, structural and behavioral patterns. However, with the advent of mobile devices, it becomes a necessity a catalog of design patterns for energy efficiency. In this work, we inspect commits, issues and pull requests of 1027 Android and 756 {iOS} apps to identify common practices when improving energy efficiency. This analysis yielded a catalog, available online, with 22 design patterns related to improving the energy efficiency of mobile apps. We argue that this catalog might be of relevance to other domains such as Cyber-Physical Systems and Internet of Things. As a side contribution, an analysis of the differences between Android and {iOS} devices shows that the Android community is more energy-aware.},
	journaltitle = {Empirical Software Engineering},
	shortjournal = {Empir Software Eng},
	author = {Cruz, Luis and Abreu, Rui},
	urldate = {2019-07-03},
	date = {2019-03-05},
	langid = {english},
	keywords = {Open source software, Catalog, Energy efficiency, Energy patterns, Mobile applications},
	file = {Springer Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7SXB6DCF\\Cruz and Abreu - 2019 - Catalog of energy patterns for mobile applications.pdf:application/pdf}
}

@online{noauthor_table_nodate,
	title = {Table of Contents · Game Programming Patterns},
	url = {https://gameprogrammingpatterns.com/contents.html},
	urldate = {2019-07-03},
	file = {Table of Contents · Game Programming Patterns:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\QJFXAKND\\contents.html:text/html}
}

@inproceedings{mantyla_taxonomy_2003,
	title = {A taxonomy and an initial empirical study of bad smells in code},
	doi = {10.1109/ICSM.2003.1235447},
	abstract = {This paper presents research in progress, as well as tentative findings related to the empirical study of so called bad code smells. We present a taxonomy that categorizes similar bad smells. We believe that taxonomy makes the smells more understandable and recognizes the relationships between smells. Additionally, we present our initial findings from an empirical study of the use of the smells for evaluating code quality in a small Finnish software product company. Our findings indicate that the taxonomy for the smells could help explain the identified correlations between the subjective evaluations of the existence of the smells.},
	eventtitle = {International Conference on Software Maintenance, 2003. {ICSM} 2003. Proceedings.},
	pages = {381--384},
	booktitle = {International Conference on Software Maintenance, 2003. {ICSM} 2003. Proceedings.},
	author = {Mantyla, M. and Vanhanen, J. and Lassenius, C.},
	date = {2003-09},
	keywords = {Internet, software maintenance, bad code smells, Cloning, code quality, correlations, empirical study, Logic, object-oriented context, object-oriented programming, program compilers, Programming, Software maintenance, Software measurement, software performance evaluation, software quality, Software quality, Software systems, taxonomy, Taxonomy, Visualization},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\UT3T6HJG\\1235447.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\TB242VJL\\Mantyla et al. - 2003 - A taxonomy and an initial empirical study of bad s.pdf:application/pdf}
}

@article{arcelli_fontana_automatic_2012,
	title = {Automatic detection of bad smells in code: An experimental assessment.},
	volume = {11},
	issn = {1660-1769},
	url = {http://www.jot.fm/contents/issue_2012_08/article5.html},
	doi = {10.5381/jot.2012.11.2.a5},
	shorttitle = {Automatic detection of bad smells in code},
	abstract = {Code smells are structural characteristics of software that may indicate a code or design problem that makes software hard to evolve and maintain, and may trigger refactoring of code. Recent research is active in deﬁning automatic detection tools to help humans in ﬁnding smells when code size becomes unmanageable for manual review. Since the deﬁnitions of code smells are informal and subjective, assessing how eﬀective code smell detection tools are is both important and hard to achieve. This paper reviews the current panorama of the tools for automatic code smell detection. It deﬁnes research questions about the consistency of their responses, their ability to expose the regions of code most aﬀected by structural decay, and the relevance of their responses with respect to future software evolution. It gives answers to them by analyzing the output of four representative code smell detectors applied to six diﬀerent versions of {GanttProject}, an open source system written in Java. The results of these experiments cast light on what current code smell detection tools are able to do and what the relevant areas for further improvement are.},
	pages = {5:1},
	number = {2},
	journaltitle = {The Journal of Object Technology},
	shortjournal = {{JOT}},
	author = {Arcelli Fontana, Francesca and Braione, Pietro and Zanoni, Marco},
	urldate = {2019-07-03},
	date = {2012},
	langid = {english},
	file = {Automatic-detection-of-bad-smells-in-code-An-experimental-assessment.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JL6NLK7Z\\Automatic-detection-of-bad-smells-in-code-An-experimental-assessment.pdf:application/pdf}
}

@inproceedings{murphy-hill_interactive_2010,
	location = {Salt Lake City, Utah, {USA}},
	title = {An interactive ambient visualization for code smells},
	isbn = {978-1-4503-0028-5},
	url = {http://portal.acm.org/citation.cfm?doid=1879211.1879216},
	doi = {10.1145/1879211.1879216},
	abstract = {Code smells are characteristics of software that indicate that code may have a design problem. Code smells have been proposed as a way for programmers to recognize the need for restructuring their software. Because code smells can go unnoticed while programmers are working, tools called smell detectors have been developed to alert programmers to the presence of smells in their code, and to help them understand the cause of those smells. In this paper, we propose a novel smell detector called Stench Blossom that provides an interactive ambient visualization designed to ﬁrst give programmers a quick, high-level overview of the smells in their code, and then, if they wish, to help in understanding the sources of those code smells. We also describe a laboratory experiment with 12 programmers that tests several hypotheses about our tool. Our ﬁndings suggest that programmers can use our tool effectively to identify smells and to make refactoring judgements. This is partly because the tool serves as a memory aid, and partly because it is more reliable and easier to use than heuristics for analyzing smells.},
	eventtitle = {the 5th international symposium},
	pages = {5},
	booktitle = {Proceedings of the 5th international symposium on Software visualization - {SOFTVIS} '10},
	publisher = {{ACM} Press},
	author = {Murphy-Hill, Emerson and Black, Andrew P.},
	urldate = {2019-07-03},
	date = {2010},
	langid = {english},
	file = {Murphy-Hill and Black - 2010 - An interactive ambient visualization for code smel.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\BNGJZALH\\Murphy-Hill and Black - 2010 - An interactive ambient visualization for code smel.pdf:application/pdf}
}

@inproceedings{emden_java_2002,
	title = {Java quality assurance by detecting code smells},
	doi = {10.1109/WCRE.2002.1173068},
	abstract = {Software inspection is a known technique for improving software quality. It involves carefully examining the code, the design, and the documentation of software and checking these for aspects that are known to be potentially problematic based on past experience. Code smells are a metaphor to describe patterns that are generally associated with bad design and bad programming practices. Originally, code smells are used to find the places in software that could benefit from refactoring. In this paper we investigate how the quality of code can be automatically assessed by checking for the presence of code smells and how this approach can contribute to automatic code inspection. We present an approach for the automatic detection and visualization of code smells and discuss how this approach can be used in the design of a software inspection tool. We illustrate the feasibility of our approach with the development of {jCOSMO}, a prototype code smell browser that detects and visualizes code smells in {JAVA} source code. Finally, we show how this tool was applied in a case study.},
	eventtitle = {Ninth Working Conference on Reverse Engineering, 2002. Proceedings.},
	pages = {97--106},
	booktitle = {Ninth Working Conference on Reverse Engineering, 2002. Proceedings.},
	author = {Emden, E. van and Moonen, L.},
	date = {2002-11},
	keywords = {Java, Prototypes, refactoring, code smells, software quality, Software quality, Visualization, automatic code inspection, Documentation, Inspection, program visualisation, quality assurance, Quality assurance, Software design, software inspection, Software prototyping, Software tools},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\YFQRPQ5S\\1173068.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\RNWYJDBY\\Emden and Moonen - 2002 - Java quality assurance by detecting code smells.pdf:application/pdf}
}

@article{counsell_common_nodate,
	title = {Common Refactorings, a Dependency Graph and some Code Smells: An Empirical Study of Java {OSS}},
	abstract = {Refactoring, as a software engineering discipline has emerged over recent years to become an important aspect of maintaining software. Refactoring refers to the restructuring of software according to specific mechanics and principles. In this paper, we describe an analysis of the results from a tool whose purpose was to identify and extract refactorings from seven open-source Java systems. In particular, we analyzed the mechanics of the most commonly and least commonly applied refactorings to try and account for their frequency. Results showed the most common refactorings of the fifteen coined a ‘Gang of Six’, to be generally those with a high in-degree and low out-degree when mapped on a dependency graph; the same refactorings also featured strongly in the remedying of bad code smells. Remarkably and surprisingly, inheritance and encapsulationbased refactorings were found to have been applied relatively infrequently - we offer explanations for why this may be the case. The paper thus identifies ‘core’ refactorings central to many of the changes made by developers on open-source systems. While we can not guarantee that developers consciously undertake refactoring in any sense, the empirical results demonstrate that simple renaming and moving fields/methods between classes are common components of open-source system re-engineering. From a wider software engineering perspective, knowledge of what a modification will incur in likely sub-tasks is of value to developers whether working on open-source or other forms of software.},
	pages = {9},
	author = {Counsell, S and Hassoun, Y and Loizou, G and Najjar, R},
	langid = {english},
	file = {Counsell et al. - Common Refactorings, a Dependency Graph and some C.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\2M6Y89TY\\Counsell et al. - Common Refactorings, a Dependency Graph and some C.pdf:application/pdf}
}

@inproceedings{khomh_exploratory_2009,
	title = {An Exploratory Study of the Impact of Code Smells on Software Change-proneness},
	doi = {10.1109/WCRE.2009.28},
	abstract = {Code smells are poor implementation choices, thought to make object-oriented systems hard to maintain. In this study, we investigate if classes with code smells are more change-prone than classes without smells. Specifically, we test the general hypothesis: classes with code smells are not more change prone than other classes. We detect 29 code smells in 9 releases of Azureus and in 13 releases of Eclipse, and study the relation between classes with these code smells and class change-proneness. We show that, in almost all releases of Azureus and Eclipse, classes with code smells are more change-prone than others, and that specific smells are more correlated than others to change-proneness. These results justify a posteriori previous work on the specification and detection of code smells and could help focusing quality assurance and testing activities.},
	eventtitle = {2009 16th Working Conference on Reverse Engineering},
	pages = {75--84},
	booktitle = {2009 16th Working Conference on Reverse Engineering},
	author = {Khomh, F. and Penta, M. Di and Gueheneuc, Y.},
	date = {2009-10},
	keywords = {software maintenance, object-oriented programming, software quality, quality assurance, Quality assurance, Azureus, class code smell detection, code smell specification, Code Smells, data mining, design pattern, Eclipse, empirical software engineering, Empirical Software Engineering, hypothesis testing, Mining Software Repositories, object-oriented software evolution, object-oriented system, Personnel, program diagnostics, program testing, Quality management, Reverse engineering, software change-proneness, Software engineering, software refactoring, software repository mining, statistical testing, Testing, testing activity},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\8MFWVQGU\\5328703.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\U6M2MV23\\Khomh et al. - 2009 - An Exploratory Study of the Impact of Code Smells .pdf:application/pdf}
}

@inproceedings{deursen_refactoring_2001,
	title = {Refactoring test code},
	abstract = {Two key aspects of extreme programming ({XP}) are unit testing and merciless refactoring. Given the fact that the ideal test code / production code ratio approaches 1:1, it is not surprising that unit tests are being refactored. We found that refactoring test code is different from refactoring production code in two ways: (1) there is a distinct set of bad smells involved, and (2) improving test code involves additional test-specific refactorings. To share our experiences with other {XP} practitioners, we describe a set of bad smells that indicate trouble in test code, and a collection of test refactorings to remove these smells.},
	author = {Deursen, Arie van and Moonen, L. M. F. and Bergh, A. and Kok, Gerard},
	date = {2001},
	keywords = {1:1 pixel mapping, Code refactoring, Code smell, Extreme programming, Halitosis, Smell Perception, Test Code, Unit testing},
	file = {Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\L76FYEZV\\Deursen et al. - 2001 - Refactoring test code.pdf:application/pdf}
}

@article{zhang_code_2011,
	title = {Code Bad Smells: a review of current knowledge},
	volume = {23},
	rights = {Copyright © 2010 John Wiley \& Sons, Ltd.},
	issn = {1532-0618},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/smr.521},
	doi = {10.1002/smr.521},
	shorttitle = {Code Bad Smells},
	abstract = {Fowler et al. identified 22 Code Bad Smells to direct the effective refactoring of code. These are increasingly being taken up by software engineers. However, the empirical basis of using Code Bad Smells to direct refactoring and to address ‘trouble’ in code is not clear, i.e., we do not know whether using Code Bad Smells to target code improvement is effective. This paper aims to identify what is currently known about Code Bad Smells. We have performed a systematic literature review of 319 papers published since Fowler et al. identified Code Bad Smells (2000 to June 2009). We analysed in detail 39 of the most relevant papers. Our findings indicate that Duplicated Code receives most research attention, whereas some Code Bad Smells, e.g., Message Chains, receive little. This suggests that our knowledge of some Code Bad Smells remains insufficient. Our findings also show that very few studies report on the impact of using Code Bad Smells, with most studies instead focused on developing tools and methods to automatically detect Code Bad Smells. This indicates an important gap in the current knowledge of Code Bad Smells. Overall this review suggests that there is little evidence currently available to justify using Code Bad Smells. Copyright © 2010 John Wiley \& Sons, Ltd.},
	pages = {179--202},
	number = {3},
	journaltitle = {Journal of Software Maintenance and Evolution: Research and Practice},
	author = {Zhang, Min and Hall, Tracy and Baddoo, Nathan},
	urldate = {2019-07-03},
	date = {2011},
	langid = {french},
	keywords = {refactoring, Code Bad Smells, empirical software engi-neering, Systematic Literature Review},
	file = {Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\SYUH7Q6F\\smr.html:text/html}
}

@incollection{yadav_review_2019,
	location = {Singapore},
	title = {A Review on Search-Based Tools and Techniques to Identify Bad Code Smells in Object-Oriented Systems},
	volume = {741},
	isbn = {9789811307607 9789811307614},
	url = {http://link.springer.com/10.1007/978-981-13-0761-4_86},
	abstract = {Researchers have provided various techniques and tools in the past few years for identiﬁcation of code smells. Due to their changing outcomes and features, the classiﬁcation, comparison, and evaluation of this existing code smell detection techniques and tool are imperative. This paper presents the current state of the art in the area of approaches that use search-based techniques to identify code smell from the source code of object-oriented systems. The classiﬁcation of code bad smells approaches is done on the basis of their detection and analysis method. The results of selected techniques were analyzed. The observations and recommendations were presented after critical analysis of existing code smell detection approaches. These observations and recommendations can help the researchers and practitioners working in the area of designing a tool/technique for code smell detection.},
	pages = {909--921},
	booktitle = {Harmony Search and Nature Inspired Optimization Algorithms},
	publisher = {Springer Singapore},
	author = {Kaur, Amandeep and Dhiman, Gaurav},
	editor = {Yadav, Neha and Yadav, Anupam and Bansal, Jagdish Chand and Deep, Kusum and Kim, Joong Hoon},
	urldate = {2019-07-04},
	date = {2019},
	langid = {english},
	doi = {10.1007/978-981-13-0761-4_86},
	file = {Kaur and Dhiman - 2019 - A Review on Search-Based Tools and Techniques to I.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\GUPGGEIX\\Kaur and Dhiman - 2019 - A Review on Search-Based Tools and Techniques to I.pdf:application/pdf}
}

@online{noauthor_large-scale_nodate,
	title = {A large-scale empirical study of code smells in {JavaScript} projects {\textbar} {SpringerLink}},
	url = {https://link.springer.com/article/10.1007/s11219-019-09442-9},
	urldate = {2019-07-04},
	file = {A large-scale empirical study of code smells in JavaScript projects | SpringerLink:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\AY64F9VP\\s11219-019-09442-9.html:text/html}
}

@inproceedings{haque_causes_2018,
	location = {Richmond, Kentucky},
	title = {Causes, impacts, and detection approaches of code smell: a survey},
	isbn = {978-1-4503-5696-1},
	url = {http://dl.acm.org/citation.cfm?doid=3190645.3190697},
	doi = {10.1145/3190645.3190697},
	shorttitle = {Causes, impacts, and detection approaches of code smell},
	abstract = {Code smells are anomalies often generated in design, implementation or maintenance phase of software development life cycle. Researchers established several catalogues characterizing the smells. Fowler and Beck developed the most popular catalogue of 22 smells covering varieties of development issues. This literature presents an overview of the existing research conducted on these 22 smells. Our motivation is to represent these smells with an easier interpretation for the software developers, determine the causes that generate these issues in applications and their impact from di erent aspects of software maintenance. This paper also highlights previous and recent research on smell detection with an e ort to categorize the approaches based on the underlying concept.},
	eventtitle = {the {ACMSE} 2018 Conference},
	pages = {1--8},
	booktitle = {Proceedings of the {ACMSE} 2018 Conference on   - {ACMSE} '18},
	publisher = {{ACM} Press},
	author = {Haque, Md Shariful and Carver, Jeff and Atkison, Travis},
	urldate = {2019-07-04},
	date = {2018},
	langid = {english},
	file = {Haque et al. - 2018 - Causes, impacts, and detection approaches of code .pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\98KI53VX\\Haque et al. - 2018 - Causes, impacts, and detection approaches of code .pdf:application/pdf}
}

@article{johannes_large-scale_2019,
	title = {A large-scale empirical study of code smells in {JavaScript} projects},
	issn = {0963-9314, 1573-1367},
	url = {http://link.springer.com/10.1007/s11219-019-09442-9},
	doi = {10.1007/s11219-019-09442-9},
	abstract = {{JavaScript} is a powerful scripting programming language that has gained a lot of attention this past decade. Initially used exclusively for client-side web development, it has evolved to become one of the most popular programming languages, with developers now using it for both client-side and server-side application development. Similar to applications written in other programming languages, {JavaScript} applications contain code smells, which are poor design choices that can negatively impact the quality of an application. In this paper, we perform a large-scale study of {JavaScript} code smells in server-side and client-side applications, with the aim to understand how they impact the fault-proneness of applications, and how they are evolved by the developers of the applications. We detect 12 types of code smells in 1807 releases of 15 popular {JavaScript} applications (i.e., express, grunt, bower, less.js, request, jquery, vue, ramda, leaflet, hexo, chart, webpack, webtorrent, moment, and riot) and perform survival analysis, comparing the time until a fault occurrence, in files containing code smells and files without code smells. We also examine the introduction and removal of the code smells in the applications using survival models. All our analysis are conducted at the granularity of the line of code. Results show that (1) on average, files without code smells have hazard rates at least 33\% lower than files with code smells. (2) Among the studied smells, “Variable Re-assign,” “Assignment In Conditional statements,” and “Complex Code” smells have the highest fault hazard rates. (3) Code smells, and particularly “Variable Re-assign,” are often introduced in the application when the files containing them are created. Moreover, they tend to remain in the applications for a long period of time; “Variable Re-assign” is also the most prevalent code smell. Overall, code smells affect negatively the quality of {JavaScript} applications and developers should consider tracking and removing them early on before the release of applications to the public.},
	journaltitle = {Software Quality Journal},
	shortjournal = {Software Qual J},
	author = {Johannes, David and Khomh, Foutse and Antoniol, Giuliano},
	urldate = {2019-07-04},
	date = {2019-03-22},
	langid = {english},
	file = {Johannes et al. - 2019 - A large-scale empirical study of code smells in Ja.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7H2YJ5RG\\Johannes et al. - 2019 - A large-scale empirical study of code smells in Ja.pdf:application/pdf}
}

@inproceedings{travassos_detecting_1999,
	location = {New York, {NY}, {USA}},
	title = {Detecting Defects in Object-oriented Designs: Using Reading Techniques to Increase Software Quality},
	isbn = {978-1-58113-238-0},
	url = {http://doi.acm.org/10.1145/320384.320389},
	doi = {10.1145/320384.320389},
	series = {{OOPSLA} '99},
	shorttitle = {Detecting Defects in Object-oriented Designs},
	abstract = {Inspections can be used to identify defects in software artifacts. In this way, inspection methods help to improve software quality, especially when used early in software development. Inspections of software design may be especially crucial since design defects (problems of correctness and completeness with respect to the requirements, internal consistency, or other quality attributes) can directly affect the quality of, and effort required for, the implementation.We have created a set of “reading techniques” (so called because they help a reviewer to “read” a design artifact for the purpose of finding relevant information) that gives specific and practical guidance for identifying defects in Object-Oriented designs. Each reading technique in the family focuses the reviewer on some aspect of the design, with the goal that an inspection team applying the entire family should achieve a high degree of coverage of the design defects.In this paper, we present an overview of this new set of reading techniques. We discuss how some elements of these techniques are based on empirical results concerning an analogous set of reading techniques that supports defect detection in requirements documents. We present an initial empirical study that was run to assess the feasibility of these new techniques, and discuss the changes made to the latest version of the techniques based on the results of this study.},
	pages = {47--56},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} Conference on Object-oriented Programming, Systems, Languages, and Applications},
	publisher = {{ACM}},
	author = {Travassos, Guilherme and Shull, Forrest and Fredericks, Michael and Basili, Victor R.},
	urldate = {2019-07-04},
	date = {1999},
	note = {event-place: Denver, Colorado, {USA}},
	keywords = {software inspection, object oriented software quality, object testing and metrics, software engineering practices},
	file = {ACM Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JPQL9GNE\\Travassos et al. - 1999 - Detecting Defects in Object-oriented Designs Usin.pdf:application/pdf}
}

@incollection{goos_refactoring:_2002,
	location = {Berlin, Heidelberg},
	title = {Refactoring: Improving the Design of Existing Code},
	volume = {2418},
	isbn = {978-3-540-44024-6 978-3-540-45672-8},
	url = {http://link.springer.com/10.1007/3-540-45672-4_31},
	shorttitle = {Refactoring},
	pages = {256--256},
	booktitle = {Extreme Programming and Agile Methods — {XP}/Agile Universe 2002},
	publisher = {Springer Berlin Heidelberg},
	author = {Fowler, Martin},
	editor = {Wells, Don and Williams, Laurie},
	editorb = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2019-07-04},
	date = {2002},
	doi = {10.1007/3-540-45672-4_31}
}

@article{tomasdottir_adoption_2018,
	title = {The Adoption of {JavaScript} Linters in Practice: A Case Study on {ESLint}},
	issn = {0098-5589},
	doi = {10.1109/TSE.2018.2871058},
	shorttitle = {The Adoption of {JavaScript} Linters in Practice},
	abstract = {A linter is a static analysis tool that warns software developers about possible code errors or violations to coding standards. By using such a tool, errors can be surfaced early in the development process when they are cheaper to fix. For a linter to be successful, it is important to understand the needs and challenges of developers when using a linter.},
	pages = {1--1},
	journaltitle = {{IEEE} Transactions on Software Engineering},
	author = {Tómasdóttir, K. F. and Aniche, M. and Deursen, A. Van},
	date = {2018},
	keywords = {Encoding, Face, Interviews, Software, Standards, Static analysis, Tools},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\X82G5ZIU\\8468105.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\FD5IIU4E\\Tómasdóttir et al. - 2018 - The Adoption of JavaScript Linters in Practice A .pdf:application/pdf}
}

@inproceedings{linares-vasquez_mining_2014,
	location = {Hyderabad, India},
	title = {Mining energy-greedy {API} usage patterns in Android apps: an empirical study},
	isbn = {978-1-4503-2863-0},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597085},
	doi = {10.1145/2597073.2597085},
	shorttitle = {Mining energy-greedy {API} usage patterns in Android apps},
	abstract = {Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps’ energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular {API} usage patterns. We present the largest to date quantitative and qualitative empirical investigation into the categories of {API} calls and usage patterns that—in the context of the Android development framework—exhibit particularly high energy consumption proﬁles. By using a hardware power monitor, we measure energy consumption of method calls when executing typical usage scenarios in 55 mobile apps from diﬀerent domains. Based on the collected data, we mine and analyze energy-greedy {APIs} and usage patterns. We zoom in and discuss the cases where either the anomalous energy consumption is unavoidable or where it is due to suboptimal usage or choice of {APIs}. Finally, we synthesize our ﬁndings into actionable knowledge and recipes for developers on how to reduce energy consumption while using certain categories of Android {APIs} and patterns.},
	eventtitle = {the 11th Working Conference},
	pages = {2--11},
	booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories - {MSR} 2014},
	publisher = {{ACM} Press},
	author = {Linares-Vásquez, Mario and Bavota, Gabriele and Bernal-Cárdenas, Carlos and Oliveto, Rocco and Di Penta, Massimiliano and Poshyvanyk, Denys},
	urldate = {2019-07-07},
	date = {2014},
	langid = {english},
	file = {Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\IYAFXLLD\\Linares-Vásquez et al. - 2014 - Mining energy-greedy API usage patterns in Android.pdf:application/pdf}
}

@article{sharma_dissertation_nodate,
	title = {Dissertation for the Award of the Doctoral Diploma Athens University of Economics and Business},
	pages = {187},
	author = {Sharma, Tushar},
	langid = {english}
}

@article{rahman_seven_nodate,
	title = {The Seven Sins: Security Smells in Infrastructure as Code Scripts},
	pages = {12},
	author = {Rahman, Akond and Parnin, Chris and Williams, Laurie},
	langid = {english},
	file = {Rahman et al. - The Seven Sins Security Smells in Infrastructure .pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7KULLMRQ\\Rahman et al. - The Seven Sins Security Smells in Infrastructure .pdf:application/pdf}
}

@article{sharma_designite_nodate,
	title = {Designite - A Quick Start Guide},
	pages = {34},
	author = {Sharma, Tushar},
	langid = {english},
	file = {Sharma - Designite - A Quick Start Guide.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\496H6ZQH\\Sharma - Designite - A Quick Start Guide.pdf:application/pdf}
}

@inproceedings{macia_defining_2010,
	title = {Defining and Applying Detection Strategies for Aspect-Oriented Code Smells},
	doi = {10.1109/SBES.2010.14},
	abstract = {A code smell is any symptom in the source code that possibly indicates a bad design or programming problem. Many code smells in aspect-oriented programming ({AOP}) are very different from those in object-oriented programming. Therefore, new detection strategies should be conceived to identify whether a particular slice of aspect-oriented code is affected by a specific smell. Unfortunately, research on {AOP} usually focuses on providing abstract descriptions of code smells, without providing operational definitions of their detection strategies. Such strategies are becoming increasingly required due to the growing use of {AOP} in the development of long-living systems, including frameworks, libraries and software product lines. This paper presents a family of metric-based strategies that support the detection of recurring smells observed in existing aspect-oriented systems. We analyzed the accuracy of such smell detection strategies and also of those previously reported in the literature. Our study involved in total 17 releases of 3 evolving aspect-oriented systems from different domains. The outcome of our evaluation suggests that strategies for previously-documented {AOP} smells do not present a satisfactory accuracy. Our analysis also revealed that: (1) newly-discovered strategies achieved better results than well-known ones, and (2) the detection strategies seem to have high accuracy with respect to the identification of both trivial and non-trivial code smells.},
	eventtitle = {2010 Brazilian Symposium on Software Engineering},
	pages = {60--69},
	booktitle = {2010 Brazilian Symposium on Software Engineering},
	author = {Macia, I. and Garcia, A. and Staa, A. v},
	date = {2010-09},
	keywords = {Measurement, code smells, Context, object-oriented programming, Programming, Software, Accuracy, {AOP}, aspect-oriented programming, Catalogs, chemioception, Code Smell, Complexity theory, Detection Strategy, Exploratory Study, libraries, long-living systems, metric-based strategies, software metrics, software product lines, source code},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\THNF4TWV\\5631504.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\84UHEDIX\\Macia et al. - 2010 - Defining and Applying Detection Strategies for Asp.pdf:application/pdf}
}

@inproceedings{marinescu_measurement_2005,
	title = {Measurement and quality in object-oriented design},
	doi = {10.1109/ICSM.2005.63},
	abstract = {In order to support the maintenance of object-oriented software systems, the quality of their design must be evaluated using adequate quantification means. In spite of the current extensive use of metrics, if used in isolation, metrics are oftentimes too fine grained to quantify comprehensively an investigated aspect of the design. To help the software engineer detect and localize design problems, the novel detection strategy mechanism is defined so that deviations from good-design principles and heuristics are quantised inform of metrics-based rules. Using detection strategies an engineer can directly localize classes or methods affected by a particular design flaw (e.g. God Class), rather than having to infer the real design problem from a large set of abnormal metric values. In order to reach the ultimate goal of bridging the gap between qualitative and quantitative statements about design, the dissertation proposes a novel type of quality model, called factor-strategy. In contrast to traditional quality models that express the goodness of design in terms of a set of metrics, this novel model relates explicitly the quality of a design to its conformance with a set of essential principles, rules and heuristics, which are quantified using detection strategies.},
	eventtitle = {21st {IEEE} International Conference on Software Maintenance ({ICSM}'05)},
	pages = {701--704},
	booktitle = {21st {IEEE} International Conference on Software Maintenance ({ICSM}'05)},
	author = {Marinescu, R.},
	date = {2005-09},
	keywords = {object-oriented methods, software maintenance, object-oriented programming, Software maintenance, Software measurement, Software quality, Software systems, Software design, software metrics, Computer industry, Design engineering, design flaw, factor-strategy quality model, Humans, Object oriented modeling, object-oriented design measurement, object-oriented design quality, object-oriented software system maintenance, Process design},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JGEJ77CL\\1510177.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\R4RH4UDR\\Marinescu - 2005 - Measurement and quality in object-oriented design.pdf:application/pdf}
}

@online{kofler_introducing_nodate,
	title = {Introducing Code Smells into Code},
	url = {http://blog.code-cop.org/2017/10/introducing-code-smells-into-code.html},
	abstract = {Code Smells  Code smells  are hints that show you potential problems in your code. They are heuristics: Like in real life, if something smel...},
	author = {Kofler, Peter},
	urldate = {2019-07-30},
	langid = {english},
	file = {Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\RK4FFZPG\\introducing-code-smells-into-code.html:text/html}
}

@software{fernandes_contribute_2016,
	title = {Contribute to eduardomorfernandes/{BadSmellsInCodeTheGame} development by creating an account on {GitHub}},
	url = {https://github.com/eduardomorfernandes/BadSmellsInCodeTheGame},
	author = {Fernandes, Eduardo},
	urldate = {2019-07-30},
	date = {2016-06-10},
	note = {original-date: 2016-06-10T20:09:00Z}
}

@software{noauthor_maze-based_2019,
	title = {A maze-based serious game for learning about code smells and code refactoring.: sqrlab/Refactor-Maze},
	rights = {{MIT}},
	url = {https://github.com/sqrlab/Refactor-Maze},
	shorttitle = {A maze-based serious game for learning about code smells and code refactoring.},
	publisher = {Software Quality Research Lab},
	urldate = {2019-07-30},
	date = {2019-02-07},
	note = {original-date: 2017-10-20T23:58:00Z}
}

@software{noauthor_amazing_2018,
	title = {The Amazing maze refactoring challenge. Contribute to xpsurgery/amazing development by creating an account on {GitHub}},
	url = {https://github.com/xpsurgery/amazing},
	publisher = {xpsurgery},
	urldate = {2019-07-30},
	date = {2018-01-03},
	note = {original-date: 2017-10-10T07:04:55Z}
}

@online{noauthor_refactoring_nodate,
	title = {Refactoring Challenge: Amazing},
	url = {http://www.mindspring.com/~alanh/refactoring/challenge.html},
	urldate = {2019-07-30},
	file = {Refactoring Challenge\: Amazing:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JQFTVFTV\\challenge.html:text/html}
}

@online{noauthor_amazing_nodate,
	title = {Amazing Refactoring Challenge},
	url = {http://wiki.c2.com/?AmazingRefactoringChallenge},
	urldate = {2019-07-30},
	file = {Amazing Refactoring Challenge:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\Y7SHGM6A\\wiki.c2.com.html:text/html}
}

@inproceedings{elezi_game_2016,
	location = {Edinburgh, Scotland, {UK}},
	title = {A game of refactoring: Studying the impact of gamification in software refactoring},
	isbn = {978-1-4503-4134-9},
	url = {http://dl.acm.org/citation.cfm?doid=2962695.2962718},
	doi = {10.1145/2962695.2962718},
	shorttitle = {A game of refactoring},
	abstract = {Software refactoring is an essential skill for developers. It improves the quality of the software and reduces maintenance costs in the long run. In this paper, we investigate the impact that gamiﬁcation can have on the refactoring process and on the usability of the existing refactoring tools. For this reason we created {CodeArena}, a gamiﬁcation system that tracks and rewards refactorings during development. We used {CodeArena} in an exploratory study which involved 12 students of computer science. Then, we collected the feedback provided by these students via a survey. Although the gamiﬁcation had less eﬀect than expected, our ﬁndings can be useful to practitioners interested in promoting refactoring tools via gamiﬁcation.},
	eventtitle = {the Scientific Workshop {XP}2016},
	pages = {1--6},
	booktitle = {Proceedings of the Scientific Workshop Proceedings of {XP}2016 on - {XP} '16 Workshops},
	publisher = {{ACM} Press},
	author = {Elezi, Leonard and Sali, Sara and Demeyer, Serge and Murgia, Alessandro and Pèrez, Javier},
	urldate = {2019-07-30},
	date = {2016},
	langid = {english},
	file = {Elezi et al. - 2016 - A game of refactoring Studying the impact of gami.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\LS6MJSQX\\Elezi et al. - 2016 - A game of refactoring Studying the impact of gami.pdf:application/pdf}
}

@inproceedings{haendler_serious_2019,
	title = {Serious Refactoring Games},
	rights = {Attribution-{NonCommercial}-{NoDerivatives} 4.0 International},
	isbn = {978-0-9981331-2-6},
	url = {http://scholarspace.manoa.hawaii.edu/handle/10125/60207},
	doi = {10.24251/HICSS.2019.927},
	abstract = {Software design issues can severely impede software development and maintenance. Thus, it is important for the success of software projects that developers are aware of bad smells in code artifacts and improve their skills to reduce these issues via refactoring. However, software refactoring is a complex activity and involves multiple tasks and aspects. Therefore, imparting competences for identifying bad smells and refactoring code efficiently is challenging for software engineering education and training.  The approaches proposed for teaching software refactoring in recent years mostly concentrate on small and artificial tasks and fall short in terms of higher level competences, such as analysis and evaluation. In this paper, we investigate the possibilities and challenges of designing serious games for software refactoring on real-world code artifacts. In particular, we propose a game design, where students can compete either against a predefined benchmark (technical debt) or against each other. In addition, we describe a lightweight architecture as the technical foundation for the game design that integrates pre-existing analysis tools such as test frameworks and software-quality analyzers. Finally, we provide an exemplary game scenario to illustrate the application of serious games in a learning setting.},
	author = {Haendler, Thorsten and Neumann, Gustaf},
	urldate = {2019-07-30},
	date = {2019-01-08},
	file = {Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\SECA2TQY\\Haendler and Neumann - 2019 - Serious Refactoring Games.pdf:application/pdf;Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\FW2Q3C8Q\\60207.html:text/html}
}

@inproceedings{haendler_interactive_2019,
	location = {Heraklion, Crete, Greece},
	title = {An Interactive Tutoring System for Training Software Refactoring:},
	isbn = {978-989-758-367-4},
	url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0007801101770188},
	doi = {10.5220/0007801101770188},
	shorttitle = {An Interactive Tutoring System for Training Software Refactoring},
	eventtitle = {11th International Conference on Computer Supported Education},
	pages = {177--188},
	booktitle = {Proceedings of the 11th International Conference on Computer Supported Education},
	publisher = {{SCITEPRESS} - Science and Technology Publications},
	author = {Haendler, Thorsten and Neumann, Gustaf and Smirnov, Fiodor},
	urldate = {2019-07-30},
	date = {2019},
	langid = {english},
	file = {Haendler et al. - 2019 - An Interactive Tutoring System for Training Softwa.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\Q8QZ7YD7\\Haendler et al. - 2019 - An Interactive Tutoring System for Training Softwa.pdf:application/pdf}
}

@inproceedings{haendler_ontology-based_2019,
	location = {Heraklion, Crete, Greece},
	title = {Ontology-based Analysis of Game Designs for Software Refactoring:},
	isbn = {978-989-758-367-4},
	url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0007878300240035},
	doi = {10.5220/0007878300240035},
	shorttitle = {Ontology-based Analysis of Game Designs for Software Refactoring},
	eventtitle = {11th International Conference on Computer Supported Education},
	pages = {24--35},
	booktitle = {Proceedings of the 11th International Conference on Computer Supported Education},
	publisher = {{SCITEPRESS} - Science and Technology Publications},
	author = {Haendler, Thorsten and Neumann, Gustaf},
	urldate = {2019-07-30},
	date = {2019},
	langid = {english},
	file = {Haendler and Neumann - 2019 - Ontology-based Analysis of Game Designs for Softwa.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\K696HTD5\\Haendler and Neumann - 2019 - Ontology-based Analysis of Game Designs for Softwa.pdf:application/pdf}
}

@inproceedings{lee_demonstration_2014,
	title = {A demonstration of gidget, a debugging game for computing education},
	doi = {10.1109/VLHCC.2014.6883060},
	abstract = {Online games have the potential to reach a wide audience and teach new skills. I propose to use Gidget, an online debugging game, to teach novices computer programming concepts in an engaging way. Learners must debug faulty programs to progress through the game, which are set up in modules to teach specific computer programming concepts. Once all the levels are complete, learners are given the option to further engage in the game by creating their own levels that can be shared with their friends and family. Over 800 people have played the game online as part of several research studies and it will be released freely to the public in the near future.},
	eventtitle = {2014 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	pages = {211--212},
	booktitle = {2014 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	author = {Lee, M. J. and Ko, A. J.},
	date = {2014-07},
	keywords = {Internet, program debugging, computer games, computer programming concepts, computer science education, Computers, computing education, Debugging, Education, Games, Gidget, Materials, online debugging game, Programming profession},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\3E4DCJPA\\6883060.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7F8GZVQN\\Lee and Ko - 2014 - A demonstration of gidget, a debugging game for co.pdf:application/pdf}
}

@article{sandalski_development_nodate,
	title = {Development of a Refactoring Learning Environment},
	abstract = {The paper describes a Refactoring Learning Environment, which is intended to analyse and assess programming code, based on refactoring rules. The Refactoring Learning Environment architecture includes an intelligent assistant, Refactoring Agent, which is responsible for the analysis and assessment of the code, written by students in real time by using a set of refactoring methods. According to the situation and based on the refactoring method, which should be applied, the agent could react in different ways. Its goal is to show the students, as much as possible, the weak points of their programming code and the possible ways of improving it.},
	pages = {19},
	author = {Sandalski, Mincho and Stoyanova-Doycheva, Asya and Popchev, Ivan and Stoyanov, Stanimir},
	langid = {english},
	file = {Sandalski et al. - Development of a Refactoring Learning Environment.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\6R6VWR8U\\Sandalski et al. - Development of a Refactoring Learning Environment.pdf:application/pdf}
}

@inproceedings{raab_codesmellexplorer:_2012,
	title = {{CodeSmellExplorer}: Tangible exploration of code smells and refactorings},
	doi = {10.1109/VLHCC.2012.6344544},
	shorttitle = {{CodeSmellExplorer}},
	abstract = {{CodeSmellExplorer} is an interactive exploration and learning tool for code smells and associated refactorings, used on a tabletop. The evaluation of our University course about good coding practices shows that undergraduate students frequently fail to recognize bad coding practices without prior training. However, the results also confirmed that gamification elements, such as coding challenges, are regarded as interesting and stimulating. {CodeSmellExplorer} is an attempt to familiarize users with good coding practices by visualizing an interactive graph network of code smells and connected refactorings. Users can explore those relationships or start challenges with built-in feedback systems.},
	eventtitle = {2012 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	pages = {261--262},
	booktitle = {2012 {IEEE} Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC})},
	author = {Raab, F.},
	date = {2012-09},
	keywords = {code smell, refactoring, software maintenance, Visualization, Software engineering, Code smell, Encoding, Software, built-in feedback system, clean code, {CodeSmellExplorer}, computer aided instruction, educational courses, Educational institutions, further education, gamification element, graph theory, interactive graph network visualization, learning tool, source coding, tabletop, tangible exploration, tangible interaction, Training, undergraduate student, University course, User interfaces, visualization},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\IYKR6RGA\\6344544.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\9UV838MJ\\Raab - 2012 - CodeSmellExplorer Tangible exploration of code sm.pdf:application/pdf}
}

@inproceedings{khandelwal_impact_2017,
	location = {New York, {NY}, {USA}},
	title = {Impact of Gamification on Code Review Process: An Experimental Study},
	isbn = {978-1-4503-4856-0},
	url = {http://doi.acm.org/10.1145/3021460.3021474},
	doi = {10.1145/3021460.3021474},
	series = {{ISEC} '17},
	shorttitle = {Impact of Gamification on Code Review Process},
	abstract = {Researchers have supported the idea of gamification to enhance students' interest in activities like code reviews, change management, knowledge management, issue tracking, etc. which might otherwise be repetitive and monotonous. We performed an experimental study consisting of nearly 180+ participants to measure the impact of gamification on code review process using 5 different code review tools, including one gamified code review instance from our extensible architectural framework. We assess the impact of gamification based on the code smells and bugs identified in a gamified and non-gamified environment as per code inspection report. Further, measurement and comparison of the quantity and usefulness of code review comments was done using machine learning techniques.},
	pages = {122--126},
	booktitle = {Proceedings of the 10th Innovations in Software Engineering Conference},
	publisher = {{ACM}},
	author = {Khandelwal, Shivam and Sripada, Sai Krishna and Reddy, Y. Raghu},
	urldate = {2019-07-30},
	date = {2017},
	note = {event-place: Jaipur, India},
	keywords = {Architectural Framework, Classification, Code Reviews, Evaluation, Gamification, Text Analysis},
	file = {ACM Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\24BQIDZR\\Khandelwal et al. - 2017 - Impact of Gamification on Code Review Process An .pdf:application/pdf}
}

@inproceedings{gonzalez_gamification_2014,
	location = {Salamanca, Spain},
	title = {Gamification in intelligent tutoring systems},
	isbn = {978-1-4503-2896-8},
	url = {http://dl.acm.org/citation.cfm?doid=2669711.2669903},
	doi = {10.1145/2669711.2669903},
	abstract = {Gamification is the use of game mechanics and strategies in nongame contexts. Currently, according to various reports, is an emerging trend in many application fields, including education. It seeks to encourage people, behavior change and improve troubleshooting. Furthermore, mobile and ubiquitous learning make possible to extend the teaching-learning beyond formal contexts such as classrooms. Moreover, while the intelligent tutoring systems have been shown to improve student achievement and enhance learning, they still have major problems in their use and need further investigation. Among them, one of the main problems found is the inappropriate use of these systems by the students, perhaps due to boredom, lack of interest or motivation and monotony, which among other factors, cause the student to behave incorrectly when interacting with these kind systems. For this reason, in this paper we present a conceptual architecture proposal for an Intelligent Tutorial System ({ITS}) known as {EMATIC} (Mathematics Education through {ICT}) that includes gamification elements as key components of the system.},
	eventtitle = {the Second International Conference},
	pages = {221--225},
	booktitle = {Proceedings of the Second International Conference on Technological Ecosystems for Enhancing Multiculturality - {TEEM} '14},
	publisher = {{ACM} Press},
	author = {González, Carina and Mora, Alberto and Toledo, Pedro},
	urldate = {2019-07-30},
	date = {2014},
	langid = {english},
	file = {González et al. - 2014 - Gamification in intelligent tutoring systems.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\M5AGGD9H\\González et al. - 2014 - Gamification in intelligent tutoring systems.pdf:application/pdf}
}

@online{noauthor_9_nodate,
	title = {The 9 Best Coding Games to Build Your Programming Skills},
	url = {https://www.makeuseof.com/tag/best-programming-games/},
	abstract = {Coding games help you learn faster with hands-on practice and experience. Plus, they're a fun way to test your programming skills!},
	titleaddon = {{MakeUseOf}},
	urldate = {2019-07-30},
	langid = {american},
	file = {Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\RNYE5AHD\\best-programming-games.html:text/html}
}

@inproceedings{raab_refactorpad:_2013,
	location = {London, United Kingdom},
	title = {{RefactorPad}: editing source code on touchscreens},
	isbn = {978-1-4503-2138-9},
	url = {http://dl.acm.org/citation.cfm?doid=2494603.2480317},
	doi = {10.1145/2494603.2480317},
	shorttitle = {{RefactorPad}},
	abstract = {Despite widespread use of touch-enabled devices, the field of software development has only slowly adopted new interaction methods for available tools. In this paper, we present our research on {RefactorPad}, a code editor for editing and restructuring source code on touchscreens. Since entering and modifying code with on-screen keyboards is time-consuming, we have developed a set of gestures that take program syntax into account and support common maintenance tasks on devices such as tablets. This work presents three main contributions: 1) a test setup that enables researchers and participants to collaboratively walk through code examples in real-time; 2) the results of a user study on editing source code with both finger and pen gestures; 3) a list of operations and some design guidelines for creators of code editors or software development environments who wish to optimize their tools for touchscreens.},
	eventtitle = {the 5th {ACM} {SIGCHI} symposium},
	pages = {223},
	booktitle = {Proceedings of the 5th {ACM} {SIGCHI} symposium on Engineering interactive computing systems - {EICS} '13},
	publisher = {{ACM} Press},
	author = {Raab, Felix and Wolff, Christian and Echtler, Florian},
	urldate = {2019-08-04},
	date = {2013},
	langid = {english},
	file = {Raab et al. - 2013 - RefactorPad editing source code on touchscreens.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\B6BBWJ3W\\Raab et al. - 2013 - RefactorPad editing source code on touchscreens.pdf:application/pdf}
}

@article{sung_game-themed_nodate,
	title = {Game-Themed Programming Assignments: The Faculty Perspective},
	abstract = {We have designed and implemented game-themed programming assignment modules targeted speciﬁcally for adoption in existing introductory programming classes. These assignments are self-contained, so that faculty members with no background in graphics or gaming can selectively pick and choose a subset to combine with their own assignments in existing classes. This paper begins with a survey of previous results. Based on this survey, the paper summarizes the important considerations when designing materials for selective adoption. The paper then describes our design, implementation, and assessment eﬀorts. Our result is a road map that guides faculty members in experimenting with gamethemed programming assignments by incrementally adopting/customizing suitable materials for their classes.},
	pages = {5},
	author = {Sung, Kelvin and Panitz, Michael and Wallace, Scott and Anderson, Ruth and Nordlinger, John},
	langid = {english},
	file = {p300-sung.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\TJWYW6LV\\p300-sung.pdf:application/pdf}
}

@patent{jr_method_2004,
	title = {Method and apparatus for identifying a winner in a bingo game},
	url = {https://patents.google.com/patent/US6755739B2/en},
	holder = {Bingo Innovation Software},
	abstract = {A method and apparatus are disclosed for identifying a winner in a bingo game. Players may obtain bingo cards from point-of-sale ({POS}) terminals that physically prints bingo cards for players in an embodiment where the player appears in person to purchase tickets, or from point-of-sale ({POS}) terminals that permit players to play bingo in an on-line environment. A game processor maintains a linked list identifying each card in play containing each possible value. Each entry in a linked list includes a pointer to the next element in the linked list. Each bingo card is represented as a bitmap containing an entry corresponding to each square on the bingo card. Each entry in the linked list also identifies the particular square on the bingo card containing the corresponding value, thereby allowing the appropriate entry in the corresponding bitmap to be identified. As each number is drawn, the game processor utilizes the linked list to identify all of the bingo cards in play having the drawn number. As each card containing the drawn number is identified, the corresponding entry in the bitmap is marked. Each possible winning pattern in a bingo game is likewise represented as a bitmap. If a bit in the winning bitmap is set to a value of 1, then the corresponding square must be set on a player's bingo card in order to match the pattern. Winning players are identified by comparing the card bitmap to each of the possible winning bitmaps. If all the 1's that are set in any bitmap for a winning pattern are also set in the card bitmap, then the card is a winning card.},
	type = {patentus},
	number = {6755739B2},
	author = {Jr, John A. Santini},
	urldate = {2019-08-20},
	date = {2004-06-29},
	langid = {english},
	keywords = {bingo, card, game, linked list, map},
	file = {Fulltext PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\ICIW63QQ\\Jr - 2004 - Method and apparatus for identifying a winner in a.pdf:application/pdf}
}

@article{sung_game-themed_2011,
	title = {Game-Themed Programming Assignment Modules: A Pathway for Gradual Integration of Gaming Context Into Existing Introductory Programming Courses},
	volume = {54},
	issn = {0018-9359},
	doi = {10.1109/TE.2010.2064315},
	shorttitle = {Game-Themed Programming Assignment Modules},
	abstract = {Despite the proven success of using computer video games as a context for teaching introductory programming ({CS}1/2) courses, barriers including the lack of adoptable materials, required background expertise (in graphics/games), and institutional acceptance still prevent interested faculty members from experimenting with this approach. Game-themed programming assignment ({GTA}) modules are designed specifically for these faculty members. The {GTA} modules are independent, and each is a self-contained game-like programming assignment that challenges students on concepts pertaining to a specific curriculum topic area. A faculty member can selectively pick and choose a subset of {GTA} modules to experiment with and gradually adopt the materials in his or her own classes. Each {GTA} module also includes a step-by-step tutorial guide that supports and encourages interested faculty to develop their own expertise and game-themed materials. This paper begins with a survey of previous results. Based on this survey, the paper summarizes the important considerations when designing materials for selective adoption. The paper then describes the design, implementation, and assessment of the {GTA} modules. The results from ongoing {GTA} workshops for {CS}1/2 faculty members and from a yearlong project in adopting the {GTA} modules in classes are then presented. In this case, the collected results verified that introductory programming concepts can be examined, practiced, and learned by means of {GTA} modules when neither the faculty nor the students involved have backgrounds in graphics or games. More importantly, these results demonstrated that it is straightforward to blend the {GTA} modules into existing classes with minimum alterations. In these ways, the {GTA} modules are excellent catalysts enabling faculty to begin exploring and developing their own expertise and materials to teach with games.},
	pages = {416--427},
	number = {3},
	journaltitle = {{IEEE} Transactions on Education},
	author = {Sung, K. and Hillyard, C. and Angotti, R. L. and Panitz, M. W. and Goldstein, D. S. and Nordlinger, J.},
	date = {2011-08},
	keywords = {computer games, computer science education, Computers, Education, Games, Materials, Programming profession, computer aided instruction, educational courses, Adaptation, assessment, assignments, computer video games, {CS}1/2, {CS}1/2 faculty members, game themed programming assignment modules, games, gaming context, Graphics, introductory programming courses, programming},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\PVKRMLYK\\5559399.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\NGTE4FF4\\Sung et al. - 2011 - Game-Themed Programming Assignment Modules A Path.pdf:application/pdf}
}

@inproceedings{trubiani_introducing_2015,
	location = {New York, {NY}, {USA}},
	title = {Introducing Software Performance Antipatterns in Cloud Computing Environments: Does It Help or Hurt?},
	isbn = {978-1-4503-3248-4},
	url = {http://doi.acm.org/10.1145/2668930.2695528},
	doi = {10.1145/2668930.2695528},
	series = {{ICPE} '15},
	shorttitle = {Introducing Software Performance Antipatterns in Cloud Computing Environments},
	abstract = {Performance assessment of cloud-based big data applications require new methodologies and tools to take into consideration on one hand the volume, the variability and the complexity of big data, and on the other hand the intrinsic dynamism of cloud environments. To this end, we introduce software performance antipatterns as reference knowledge to capture the well-known bad design practices that lead to software products suffering by poor performance. This paper discusses some of the challenges and opportunities of research while introducing software performance antipatterns in cloud computing environments. We present a model-based framework that makes use of software performance antipatterns to improve the Quality-of-Service ({QoS}) objectives of cloud-based big data applications.},
	pages = {207--210},
	booktitle = {Proceedings of the 6th {ACM}/{SPEC} International Conference on Performance Engineering},
	publisher = {{ACM}},
	author = {Trubiani, Catia},
	urldate = {2019-08-27},
	date = {2015},
	note = {event-place: Austin, Texas, {USA}},
	keywords = {big data applications, cloud computing environments, software performance antipatterns},
	file = {ACM Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\ZMICZETY\\Trubiani - 2015 - Introducing Software Performance Antipatterns in C.pdf:application/pdf}
}

@article{zimmermann_architectural_2017,
	title = {Architectural refactoring for the cloud: a decision-centric view on cloud migration},
	volume = {99},
	issn = {1436-5057},
	url = {https://doi.org/10.1007/s00607-016-0520-y},
	doi = {10.1007/s00607-016-0520-y},
	shorttitle = {Architectural refactoring for the cloud},
	abstract = {Unlike code refactoring of programs, architectural refactoring of systems is not commonly practiced yet. However, legacy systems typically have to be refactored when migrating them to the cloud; otherwise, these systems may run in the cloud, but cannot fully benefit from cloud properties such as elasticity. One reason for the lack of adoption of architectural refactoring is that many of the involved artefacts are intangible—architectural refactoring therefore is harder to grasp than code refactoring. To overcome this inhibitor, we take a task-centric view on the subject and introduce an architectural refactoring template that highlights the architectural decisions to be revisited when refactoring application architectures for the cloud; in this approach, architectural smells are derived from quality stories. We also present a number of common architectural refactorings and evaluate existing patterns regarding their cloud affinity. The final contribution of this paper is the identification of an initial catalog of architectural refactorings for cloud application design. This refactoring catalog was compiled from the cloud patterns literature as well as project experiences. Cloud knowledge and supporting templates have been validated via action research and implementation in cooperation with practitioners.},
	pages = {129--145},
	number = {2},
	journaltitle = {Computing},
	shortjournal = {Computing},
	author = {Zimmermann, Olaf},
	urldate = {2019-08-27},
	date = {2017-02-01},
	langid = {english},
	keywords = {68N99, Architectural decisions, Architectural patterns, Cloud computing, Knowledge management, Reengineering, Refactoring, Software evolution and Maintenance},
	file = {Springer Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\RM6H38B3\\Zimmermann - 2017 - Architectural refactoring for the cloud a decisio.pdf:application/pdf}
}

@article{taibi_processes_2017,
	title = {Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation},
	volume = {4},
	issn = {2325-6095},
	doi = {10.1109/MCC.2017.4250931},
	shorttitle = {Processes, Motivations, and Issues for Migrating to Microservices Architectures},
	abstract = {In this paper, we identify a process framework based on the comparison of three different migration processes adopted by the interviewed practitioners, together with the common motivations and issues that commonly take place during migrations. In this work, we describe the results and provide an analysis of our survey, which includes a comparison of the migration processes, a ranking of motivations, and issues and some insights into the benefits achieved after the adoption. Maintainability and scalability were consistently ranked as the most important motivations, along with a few other technical and nontechnical motivations. Although return on investment was expected to take longer, the reduced maintenance effort in the long run was considered to highly compensate for this.},
	pages = {22--32},
	number = {5},
	journaltitle = {{IEEE} Cloud Computing},
	author = {Taibi, D. and Lenarduzzi, V. and Pahl, C.},
	date = {2017-09},
	keywords = {Cloud computing, cloud computing, cloud containers, cloud migration, cloud native, Companies, Computer architecture, Docker, Investment, maintainability motivation, Maintenance engineering, microservice architectures, microservices, migration processes, nontechnical motivation, return on investment, Scalability, scalability motivation, service oriented architectures {SOA}, software architecture, technical motivations, Web services},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\Z9KDM8KA\\8125558.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\5EC3BVAH\\Taibi et al. - 2017 - Processes, Motivations, and Issues for Migrating t.pdf:application/pdf}
}

@article{kwon_cloud_2014,
	title = {Cloud refactoring: automated transitioning to cloud-based services},
	volume = {21},
	issn = {1573-7535},
	url = {https://doi.org/10.1007/s10515-013-0136-9},
	doi = {10.1007/s10515-013-0136-9},
	shorttitle = {Cloud refactoring},
	abstract = {Using cloud-based services can improve the performance, reliability, and scalability of a software application. However, transitioning an application to use cloud-based services is difficult, costly, and error-prone. The required re-engineering effort includes migrating to the cloud the functionality to be accessed as remote cloud-based services and re-targeting the client code accordingly. In addition, the client must be able to detect and handle the faults raised in the process of invoking the services. As a means of streamlining this transitioning, we developed a set of refactoring techniques—automated, {IDE}-assisted program transformations that eliminate the need to change programs by hand. In particular, we show how a programmer can extract services, add fault tolerance functionality, and adapt client code to invoke cloud services via refactorings integrated with a modern {IDE}. As a validation, we have applied our approach to automatically transform two third-party Java applications to use cloud-based services. We have also applied our approach to re-engineer a suite of services operated by General Electric to use cloud-based resources to better satisfy the {GE} business requirements.},
	pages = {345--372},
	number = {3},
	journaltitle = {Automated Software Engineering},
	shortjournal = {Autom Softw Eng},
	author = {Kwon, Young-Woo and Tilevich, Eli},
	urldate = {2019-08-29},
	date = {2014-09-01},
	langid = {english},
	keywords = {Cloud computing, Refactoring, Fault-tolerance, Program transformation, Service extraction, Services},
	file = {Springer Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7YEBJB9I\\Kwon and Tilevich - 2014 - Cloud refactoring automated transitioning to clou.pdf:application/pdf}
}

@inproceedings{zhao_code_2018,
	title = {Code Refactoring Based on {MapReduce} in Cloud Migration},
	doi = {10.1109/BDCloud.2018.00154},
	abstract = {With the advent of big data era, the response speed of traditional legacy systems can no longer meet the requirements of users. Many organizations are migrating their legacy systems from a local machine to the cloud so as to reuse the legacy systems as well as improve the performance of big data processing. The {MapReduce} model of cloud computing makes parallel and distributed programming over a cluster of machines more convenient. This paper presents an approach to refactor the specific sequential code into {MapReduce} model in cloud migration, and proposes a tool to support the process of code refactoring.},
	eventtitle = {2018 {IEEE} Intl Conf on Parallel Distributed Processing with Applications, Ubiquitous Computing Communications, Big Data Cloud Computing, Social Computing Networking, Sustainable Computing Communications ({ISPA}/{IUCC}/{BDCloud}/{SocialCom}/{SustainCom})},
	pages = {1042--1043},
	booktitle = {2018 {IEEE} Intl Conf on Parallel Distributed Processing with Applications, Ubiquitous Computing Communications, Big Data Cloud Computing, Social Computing Networking, Sustainable Computing Communications ({ISPA}/{IUCC}/{BDCloud}/{SocialCom}/{SustainCom})},
	author = {Zhao, J. and Wang, W. and Yang, H.},
	date = {2018-12},
	keywords = {Java, software maintenance, Tools, Cloud computing, cloud computing, cloud migration, Aging, Big Data, Big Data processing, Business, cluster computing, code refactoring, Code Refactoring, Legacy Code, {MapReduce}, Computational modeling, distributed programming, {MapReduce} model, parallel programming, sequential code},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\IU3KKU5B\\8672235.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\DK4DYPJD\\Zhao et al. - 2018 - Code Refactoring Based on MapReduce in Cloud Migra.pdf:application/pdf}
}

@inproceedings{li_performance-aware_2017,
	title = {Performance-Aware Refactoring of Cloud-Based Big Data Applications},
	doi = {10.1109/CSCI.2017.264},
	abstract = {The problem of optimizing performance of cloud-based Big Data applications is critical in the cloud computing domain. In this paper, we propose a performance-aware approach that not only considers the cost of the cloud resources but also focuses on the dependency constraints among the deployed components to help dynamically refactoring the application. Furthermore, our approach closes the gap between design time models and runtime models. The feedback can be provided to application designers to iteratively enhance the application design and improve the application deployment. We have experimented our approach on the Wikistats application and the results show that the proposed approach effectively refactors the deployment based on different {QoS} metrics (e.g., utilization, cost, availability) of the cloud resources and dependency constraints.},
	eventtitle = {2017 International Conference on Computational Science and Computational Intelligence ({CSCI})},
	pages = {1505--1510},
	booktitle = {2017 International Conference on Computational Science and Computational Intelligence ({CSCI})},
	author = {Li, C. and Casale, G.},
	date = {2017-12},
	keywords = {software maintenance, cloud computing, Big Data, application deployment, application design, application refactoring, cloud computing domain, cloud resources, cloud-based Big Data applications, dependency constraints, design time models, performance-aware refactoring, {QoS} metrics, resource management, software performance engineering, Wikistats application},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\W9RTVW4H\\8561027.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\LGCMH4FU\\Li and Casale - 2017 - Performance-Aware Refactoring of Cloud-Based Big D.pdf:application/pdf}
}

@inproceedings{dubois_model-driven_2016,
	title = {Model-Driven Application Refactoring to Minimize Deployment Costs in Preemptible Cloud Resources},
	doi = {10.1109/CLOUD.2016.0052},
	abstract = {Performance assessment of cloud-based applications requires new methodologies to deal with the complexity of software systems and the variability of cloud resources. In this paper, we address the problem of reducing the total costs for running cloud-based applications while fulfilling service-level objectives ({SLOs}). To this end, we define an approach to refactor a cloud application in such a way that, when it is deployed, it requires less computational capacity and therefore less resources. We experimented our approach on top of a modified optimal provisioning heuristic designed for preemptible cloud resources and the results show that it reduces deployment costs, up to 60\% when compared to the same approach, but without model-driven application refactoring.},
	eventtitle = {2016 {IEEE} 9th International Conference on Cloud Computing ({CLOUD})},
	pages = {335--342},
	booktitle = {2016 {IEEE} 9th International Conference on Cloud Computing ({CLOUD})},
	author = {Dubois, D. J. and Trubiani, C. and Casale, G.},
	date = {2016-06},
	keywords = {Cloud computing, cloud computing, Computational modeling, application refactoring, software performance engineering, deployment cost minimization, Load modeling, model-driven application refactoring, preemptible cloud resources, resource allocation, Resource management, resource provisioning, Servers, service-level objectives, Unified modeling language},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\WKGQDSFM\\7820289.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\HV2WN4R5\\Dubois et al. - 2016 - Model-Driven Application Refactoring to Minimize D.pdf:application/pdf}
}

@inproceedings{zhao_refactoring_2018,
	title = {Refactoring {OpenMP} Code Based on {MapReduce} Model},
	doi = {10.1109/BDCloud.2018.00153},
	abstract = {In multi-core era, much software has been developed using parallel programming technology, such as {OpenMP}. However, with the rise of the Internet, the data is growing dramatically. Due to the limitation of computing power and memory capacity, {OpenMP} applications cannot satisfy the needs of user efficiently. The flexibility and scalability of the cloud provide a new way to solve this problem. {MapReduce}, a parallel programming model in cloud computing, provides a solution for massive data processing. So, it needs to be considered that how to refactor the legacy {OpenMP} code to {MapReduce} model. A related refactoring approach was proposed, and a prototype tool, O2MR, was developed for the above-mentioned problem in this paper. Through experiment validation, the approach is effective, and the tool is helpful in the process of refactoring.},
	eventtitle = {2018 {IEEE} Intl Conf on Parallel Distributed Processing with Applications, Ubiquitous Computing Communications, Big Data Cloud Computing, Social Computing Networking, Sustainable Computing Communications ({ISPA}/{IUCC}/{BDCloud}/{SocialCom}/{SustainCom})},
	pages = {1040--1041},
	booktitle = {2018 {IEEE} Intl Conf on Parallel Distributed Processing with Applications, Ubiquitous Computing Communications, Big Data Cloud Computing, Social Computing Networking, Sustainable Computing Communications ({ISPA}/{IUCC}/{BDCloud}/{SocialCom}/{SustainCom})},
	author = {Zhao, J. and Zhang, M.},
	date = {2018-12},
	keywords = {Internet, Prototypes, software maintenance, Tools, Cloud computing, cloud computing, code refactoring, Computational modeling, {MapReduce} model, parallel programming, Load modeling, cloud scalability, data handling, Data models, legacy {OpenMP} code, {MapReduce}, massive data, massive data processing, memory capacity, multicore era, O2MR prototype tool, {OpenMP}, {OpenMP} code refactoring, parallel programming model, parallel programming technology, software prototyping, software reliability, software tools, Task analysis},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\4MHILXUQ\\8672303.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\MCMK7TNZ\\Zhao and Zhang - 2018 - Refactoring OpenMP Code Based on MapReduce Model.pdf:application/pdf}
}

@online{noauthor_detecting_nodate,
	title = {Detecting Cloud (Anti)Patterns: {OCCI} Perspective {\textbar} {SpringerLink}},
	url = {https://link.springer.com/chapter/10.1007/978-3-319-46295-0_13},
	urldate = {2019-10-10},
	file = {Detecting Cloud (Anti)Patterns\: OCCI Perspective | SpringerLink:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\5I43GQVI\\978-3-319-46295-0_13.html:text/html}
}

@incollection{sheng_detecting_2016,
	location = {Cham},
	title = {Detecting Cloud (Anti)Patterns: {OCCI} Perspective},
	volume = {9936},
	isbn = {978-3-319-46294-3 978-3-319-46295-0},
	url = {http://link.springer.com/10.1007/978-3-319-46295-0_13},
	shorttitle = {Detecting Cloud (Anti)Patterns},
	pages = {202--218},
	booktitle = {Service-Oriented Computing},
	publisher = {Springer International Publishing},
	author = {Brabra, Hayet and Mtibaa, Achraf and Sliman, Layth and Gaaloul, Walid and Benatallah, Boualem and Gargouri, Faiez},
	editor = {Sheng, Quan Z. and Stroulia, Eleni and Tata, Samir and Bhiri, Sami},
	urldate = {2019-10-11},
	date = {2016},
	doi = {10.1007/978-3-319-46295-0_13}
}

@online{noauthor_how_nodate,
	title = {How Is Video Game Development Different from Software Development in Open Source? - {IEEE} Conference Publication},
	url = {https://ieeexplore.ieee.org/abstract/document/8595223},
	urldate = {2019-10-23},
	file = {How Is Video Game Development Different from Software Development in Open Source? - IEEE Conference Publication:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JQDHFEJD\\8595223.html:text/html}
}

@article{gottschalk_removing_nodate,
	title = {Removing Energy Code Smells with Reengineering Services},
	abstract = {Due to the increasing consumer adoption of mobile devices, like smart phones and tablet {PCs}, saving energy is becoming more and more important. Users desire more functionality and longer battery cycles. While modern mobile computing devices offer hardware optimized for low energy consumption, applications often do not make proper use of energy-saving capabilities. This paper proposes detecting and removing energy-wasteful code using software reengineering services, like code analysis and restructuring, to optimize the energy consumption of mobile devices.},
	pages = {15},
	author = {Gottschalk, Marion and Joseﬁok, Mirco and Jelschen, Jan and Winter, Andreas},
	langid = {english},
	file = {Gottschalk et al. - Removing Energy Code Smells with Reengineering Ser.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\PPTYXP62\\Gottschalk et al. - Removing Energy Code Smells with Reengineering Ser.pdf:application/pdf}
}

@inproceedings{guzman_sentiment_2014,
	location = {Hyderabad, India},
	title = {Sentiment analysis of commit comments in {GitHub}: an empirical study},
	isbn = {978-1-4503-2863-0},
	url = {http://dl.acm.org/citation.cfm?doid=2597073.2597118},
	doi = {10.1145/2597073.2597118},
	shorttitle = {Sentiment analysis of commit comments in {GitHub}},
	abstract = {Emotions have a high impact in productivity, task quality, creativity, group rapport and job satisfaction. In this work we use lexical sentiment analysis to study emotions expressed in commit comments of diﬀerent open source projects and analyze their relationship with diﬀerent factors such as used programming language, time and day of the week in which the commit was made, team distribution and project approval. Our results show that projects developed in Java tend to have more negative commit comments, and that projects that have more distributed teams tend to have a higher positive polarity in their emotional content. Additionally, we found that commit comments written on Mondays tend to a more negative emotion. While our results need to be conﬁrmed by a more representative sample they are an initial step into the study of emotions and related factors in open source projects.},
	eventtitle = {the 11th Working Conference},
	pages = {352--355},
	booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories - {MSR} 2014},
	publisher = {{ACM} Press},
	author = {Guzman, Emitza and Azócar, David and Li, Yang},
	urldate = {2019-11-08},
	date = {2014},
	langid = {english},
	file = {Guzman et al. - 2014 - Sentiment analysis of commit comments in GitHub a.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\DSMZIZBJ\\Guzman et al. - 2014 - Sentiment analysis of commit comments in GitHub a.pdf:application/pdf}
}

@inproceedings{moura_mining_2015,
	location = {Florence, Italy},
	title = {Mining Energy-Aware Commits},
	isbn = {978-0-7695-5594-2},
	url = {http://ieeexplore.ieee.org/document/7180067/},
	doi = {10.1109/MSR.2015.13},
	abstract = {Over the last years, energy consumption has become a ﬁrst-class citizen in software development practice. While energy-efﬁcient solutions on lower-level layers of the software stack are well-established, there is convincing evidence that even better results can be achieved by encouraging practitioners to participate in the process. For instance, previous work has shown that using a newer version of a concurrent data structure can yield a 2.19x energy savings when compared to the old associative implementation [75]. Nonetheless, little is known about how much software engineers are employing energy-efﬁcient solutions in their applications and what solutions they employ for improving energy-efﬁciency. In this paper we present a qualitative study of “energy-aware commits”. Using Github as our primary data source, we perform a thorough analysis on an initial sample of 2,189 commits and carefully curate a set of 371 energy-aware commits spread over 317 real-world non-trivial applications. Our study reveals that software developers heavily rely on lowlevel energy management approaches, such as frequency scaling and multiple levels of idleness. Also, our ﬁndings suggest that ill-chosen energy saving techniques can impact the correctness of an application. Yet, we found what we call “energy-aware interfaces”, which are means for clients (e.g., developers or endusers) to save energy in their applications just by using a function, abstracting away the low-level implementation details.},
	eventtitle = {2015 {IEEE}/{ACM} 12th Working Conference on Mining Software Repositories ({MSR})},
	pages = {56--67},
	booktitle = {2015 {IEEE}/{ACM} 12th Working Conference on Mining Software Repositories},
	publisher = {{IEEE}},
	author = {Moura, Irineu and Pinto, Gustavo and Ebert, Felipe and Castor, Fernando},
	urldate = {2019-11-10},
	date = {2015-05},
	langid = {english},
	file = {Moura et al. - 2015 - Mining Energy-Aware Commits.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\UNF92328\\Moura et al. - 2015 - Mining Energy-Aware Commits.pdf:application/pdf}
}

@article{fereday_demonstrating_2006,
	title = {Demonstrating Rigor Using Thematic Analysis: A Hybrid Approach of Inductive and Deductive Coding and Theme Development},
	volume = {5},
	issn = {1609-4069, 1609-4069},
	url = {http://journals.sagepub.com/doi/10.1177/160940690600500107},
	doi = {10.1177/160940690600500107},
	shorttitle = {Demonstrating Rigor Using Thematic Analysis},
	abstract = {In this article, the authors describe how they used a hybrid process of inductive and deductive thematic analysis to interpret raw data in a doctoral study on the role of performance feedback in the self-assessment of nursing practice. The methodological approach integrated data-driven codes with theory-driven ones based on the tenets of social phenomenology. The authors present a detailed exemplar of the staged process of data coding and identification of themes. This process demonstrates how analysis of the raw data from interview transcripts and organizational documents progressed toward the identification of overarching themes that captured the phenomenon of performance feedback as described by participants in the study.},
	pages = {80--92},
	number = {1},
	journaltitle = {International Journal of Qualitative Methods},
	shortjournal = {International Journal of Qualitative Methods},
	author = {Fereday, Jennifer and Muir-Cochrane, Eimear},
	urldate = {2019-11-10},
	date = {2006-03},
	langid = {english},
	file = {Fereday and Muir-Cochrane - 2006 - Demonstrating Rigor Using Thematic Analysis A Hyb.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JFLR9CTI\\Fereday and Muir-Cochrane - 2006 - Demonstrating Rigor Using Thematic Analysis A Hyb.pdf:application/pdf}
}

@online{noauthor_brandonrose.org_nodate,
	title = {brandonrose.org},
	url = {http://brandonrose.org/},
	urldate = {2019-11-12},
	file = {brandonrose.org:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\YWL5LPST\\brandonrose.org.html:text/html}
}

@online{noauthor_thirteen_nodate,
	title = {Thirteen Years of Bad Game Code · Evan Todd},
	url = {http://etodd.io/2017/03/29/thirteen-years-of-bad-game-code/},
	urldate = {2019-11-13},
	file = {Thirteen Years of Bad Game Code · Evan Todd:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\E4NWDX5T\\thirteen-years-of-bad-game-code.html:text/html}
}

@online{noauthor_document_nodate,
	title = {Document Clustering with Python},
	url = {http://brandonrose.org/clustering},
	urldate = {2019-11-14},
	file = {Document Clustering with Python:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\KLATESFY\\clustering.html:text/html}
}

@online{noauthor_brandonrose.org_nodate-1,
	title = {brandonrose.org},
	url = {http://brandonrose.org/},
	urldate = {2019-11-14},
	file = {brandonrose.org:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\UNVJBU9C\\brandonrose.org.html:text/html}
}

@article{fowler_refactoring_nodate,
	title = {Refactoring - Improving the Design of Existing Code},
	pages = {337},
	author = {Fowler, Martin and Beck, Kent and Brant, John},
	langid = {english},
	file = {Fowler.M-Refactoring-1999.www.EBooksWorld.ir.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\KQYNFDKM\\Fowler.M-Refactoring-1999.www.EBooksWorld.ir.pdf:application/pdf}
}

@video{noauthor_design_nodate,
	title = {Design Patterns in Game Development},
	url = {https://www.youtube.com/watch?v=8f_3x79PEZQ},
	abstract = {For {CSCI} 5448, {CU} Boulder Fall 2015. By John Chamberlin and Josh Killinger},
	urldate = {2019-11-17}
}

@inproceedings{hecht_approach_2015,
	location = {Florence, Italy},
	title = {An Approach to Detect Android Antipatterns},
	isbn = {978-1-4799-1934-5},
	url = {http://ieeexplore.ieee.org/document/7203064/},
	doi = {10.1109/ICSE.2015.243},
	abstract = {Mobile applications are becoming complex software systems that must be developed quickly and evolve regularly to ﬁt new user requirements and execution contexts. However, addressing these constraints may result in poor design choices, known as antipatterns, which may degrade software quality and performance. Thus, the automatic detection of antipatterns is an important activity that eases the future maintenance and evolution tasks. Moreover, it helps developers to refactor their applications and thus, to improve their quality. While antipatterns are well-known in object-oriented applications, their study in mobile applications is still in their infancy. In this paper, we presents a tooled approach, called {PAPRIKA}, to analyze Android applications and to detect object-oriented and Androidspeciﬁc antipatterns from binaries of applications.},
	eventtitle = {2015 {IEEE}/{ACM} 37th {IEEE} International Conference on Software Engineering ({ICSE})},
	pages = {766--768},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} International Conference on Software Engineering},
	publisher = {{IEEE}},
	author = {Hecht, Geoffrey},
	urldate = {2019-11-18},
	date = {2015-05},
	langid = {english},
	file = {Hecht - 2015 - An Approach to Detect Android Antipatterns.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\7TVPIUXH\\Hecht - 2015 - An Approach to Detect Android Antipatterns.pdf:application/pdf}
}

@article{chatterjee_algorithms_2010,
	title = {Algorithms for Game Metrics},
	volume = {6},
	issn = {18605974},
	url = {http://arxiv.org/abs/0809.4326},
	doi = {10.2168/LMCS-6(3:13)2010},
	abstract = {Simulation and bisimulation metrics for stochastic systems provide a quantitative generalization of the classical simulation and bisimulation relations. These metrics capture the similarity of states with respect to quantitative specifications written in the quantitative \{{\textbackslash}mu\}-calculus and related probabilistic logics. We first show that the metrics provide a bound for the difference in long-run average and discounted average behavior across states, indicating that the metrics can be used both in system verification, and in performance evaluation. For turn-based games and {MDPs}, we provide a polynomial-time algorithm for the computation of the one-step metric distance between states. The algorithm is based on linear programming; it improves on the previous known exponential-time algorithm based on a reduction to the theory of reals. We then present {PSPACE} algorithms for both the decision problem and the problem of approximating the metric distance between two states, matching the best known algorithms for Markov chains. For the bisimulation kernel of the metric our algorithm works in time O(n{\textasciicircum}4) for both turn-based games and {MDPs}; improving the previously best known O(n{\textasciicircum}9{\textbackslash}cdot log(n)) time algorithm for {MDPs}. For a concurrent game G, we show that computing the exact distance between states is at least as hard as computing the value of concurrent reachability games and the square-root-sum problem in computational geometry. We show that checking whether the metric distance is bounded by a rational r, can be done via a reduction to the theory of real closed fields, involving a formula with three quantifier alternations, yielding O({\textbar}G{\textbar}{\textasciicircum}O({\textbar}G{\textbar}{\textasciicircum}5)) time complexity, improving the previously known reduction, which yielded O({\textbar}G{\textbar}{\textasciicircum}O({\textbar}G{\textbar}{\textasciicircum}7)) time complexity. These algorithms can be iterated to approximate the metrics using binary search.},
	pages = {13},
	number = {3},
	journaltitle = {Logical Methods in Computer Science},
	shortjournal = {Log.Meth.Comput.Sci.},
	author = {Chatterjee, Krishnendu and de Alfaro, Luca and Majumdar, Rupak and Raman, Vishwanath},
	urldate = {2019-11-18},
	date = {2010-09-01},
	eprinttype = {arxiv},
	eprint = {0809.4326},
	keywords = {Computer Science - Computer Science and Game Theory, F.4.1, F.1.1}
}

@article{livingstone_rapid_2010,
	title = {On the Rapid Rise of Social Networking Sites: New Findings and Policy Implications},
	volume = {24},
	issn = {1099-0860},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1099-0860.2009.00243.x},
	doi = {10.1111/j.1099-0860.2009.00243.x},
	shorttitle = {On the Rapid Rise of Social Networking Sites},
	abstract = {Social networking sites have been rapidly adopted by children and, especially, teenagers and young people worldwide, enabling new opportunities for the presentation of the self, learning, construction of a wide circle of relationships, and the management of privacy and intimacy. On the other hand, there are also concerns that social networking increases the likelihood of new risks to the self, these centring on loss of privacy, bullying, harmful contacts and more. This article reviews recent findings regarding children and teenagers’ social networking practices in order to identify implications for future research and public policy. These focus on the interdependencies between opportunities and risks, the need for digital or media literacy education, the importance of building safety considerations into the design and management of social networking sites, the imperative for greater attention to ‘at risk’ children in particular, and the importance of a children’s rights framework in developing evidence-based policy in this area.},
	pages = {75--83},
	number = {1},
	journaltitle = {Children \& Society},
	author = {Livingstone, Sonia and Brake, David R.},
	urldate = {2020-01-04},
	date = {2010},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\5YVHT75M\\Livingstone and Brake - 2010 - On the Rapid Rise of Social Networking Sites New .pdf:application/pdf;Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\J522TW5W\\j.1099-0860.2009.00243.html:text/html}
}

@online{noauthor_towards_nodate,
	title = {Towards Computational Notebooks for {IoT} Development {\textbar} Extended Abstracts of the 2019 {CHI} Conference on Human Factors in Computing Systems},
	url = {https://dl.acm.org/doi/10.1145/3290607.3312963},
	urldate = {2020-01-04},
	file = {Towards Computational Notebooks for IoT Development | Extended Abstracts of the 2019 CHI Conference on Human Factors in Computing Systems:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\SUG9QSR9\\3290607.html:text/html}
}

@online{noauthor_-_nodate,
	title = {- Document - Why Jupyter is data scientists' computational notebook of choice},
	url = {https://go.gale.com/ps/anonymous?id=GALE%7CA573082717&sid=googleScholar&v=2.1&it=r&linkaccess=abs&issn=00280836&p=HRCA&sw=w},
	urldate = {2020-01-04},
	file = {- Document - Why Jupyter is data scientists' computational notebook of choice:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\TH5TIL79\\anonymous.html:text/html}
}

@inproceedings{ohara_computational_2015,
	title = {Computational Notebooks for {AI} Education},
	rights = {Authors who publish a paper in this conference agree to the following terms:  1. Author(s) agree to transfer their copyrights in their article/paper to the Association for the Advancement of Artificial Intelligence ({AAAI}), in order to deal with future requests for reprints, translations, anthologies, reproductions, excerpts, and other publications. This grant will include, without limitation, the entire copyright in the article/paper in all countries of the world, including all renewals, extensions, and reversions thereof, whether such rights current exist or hereafter come into effect, and also the exclusive right to create electronic versions of the article/paper, to the extent that such right is not subsumed under copyright.  2. The author(s) warrants that they are the sole author and owner of the copyright in the above article/paper, except for those portions shown to be in quotations; that the article/paper is original throughout; and that the undersigned right to make the grants set forth above is complete and unencumbered.  3. The author(s) agree that if anyone brings any claim or action alleging facts that, if true, constitute a breach of any of the foregoing warranties, the author(s) will hold harmless and indemnify {AAAI}, their grantees, their licensees, and their distributors against any liability, whether under judgment, decree, or compromise, and any legal fees and expenses arising out of that claim or actions, and the undersigned will cooperate fully in any defense {AAAI} may make to such claim or action. Moreover, the undersigned agrees to cooperate in any claim or other action seeking to protect or enforce any right the undersigned has granted to {AAAI} in the article/paper. If any such claim or action fails because of facts that constitute a breach of any of the foregoing warranties, the undersigned agrees to reimburse whomever brings such claim or action for expenses and attorneys\&rsquo; fees incurred therein.  4. Author(s) retain all proprietary rights other than copyright (such as patent rights).  5. Author(s) may make personal reuse of all or portions of the above article/paper in other works of their own authorship.  6. Author(s) may reproduce, or have reproduced, their article/paper for the author\&rsquo;s personal use, or for company use provided that {AAAI} copyright and the source are indicated, and that the copies are not used in a way that implies {AAAI} endorsement of a product or service of an employer, and that the copies per se are not offered for sale. The foregoing right shall not permit the posting of the article/paper in electronic or digital form on any computer network, except by the author or the author\&rsquo;s employer, and then only on the author\&rsquo;s or the employer\&rsquo;s own web page or ftp site. Such web page or ftp site, in addition to the aforementioned requirements of this Paragraph, must provide an electronic reference or link back to the {AAAI} electronic server, and shall not post other {AAAI} copyrighted materials not of the author\&rsquo;s or the employer\&rsquo;s creation (including tables of contents with links to other papers) without {AAAI}\&rsquo;s written permission.  7. Author(s) may make limited distribution of all or portions of their article/paper prior to publication.  8. In the case of work performed under U.S. Government contract, {AAAI} grants the U.S. Government royalty-free permission to reproduce all or portions of the above article/paper, and to authorize others to do so, for U.S. Government purposes.  9. In the event the above article/paper is not accepted and published by {AAAI}, or is withdrawn by the author(s) before acceptance by {AAAI}, this agreement becomes null and void.},
	url = {https://www.aaai.org/ocs/index.php/FLAIRS/FLAIRS15/paper/view/10349},
	abstract = {Computational notebooks are documents that serve dual purposes: they serve as an archive format containing code, text, images and equations; but they can also be run like computer programs. This paper explores the use of these new computational notebooks to teach {AI} and introduces tools that we have developed — {ICalico} and Calysto — to facilitate that use. Not only do these new tools broaden the languages and contexts available to students exploring notebook-based {AI} computing, but they offer a new mode of teaching and learning for the {AI} classroom.},
	eventtitle = {The Twenty-Eighth International Flairs Conference},
	booktitle = {The Twenty-Eighth International Flairs Conference},
	author = {O'Hara, Keith and Blank, Douglas and Marshall, James},
	urldate = {2020-01-04},
	date = {2015-04-07},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JCMYRJEU\\O'Hara et al. - 2015 - Computational Notebooks for AI Education.pdf:application/pdf;Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\JKKXTRGK\\10349.html:text/html}
}

@inproceedings{corno_towards_2019,
	location = {Glasgow, Scotland Uk},
	title = {Towards Computational Notebooks for {IoT} Development},
	isbn = {978-1-4503-5971-9},
	url = {http://dl.acm.org/citation.cfm?doid=3290607.3312963},
	doi = {10.1145/3290607.3312963},
	eventtitle = {Extended Abstracts of the 2019 {CHI} Conference},
	pages = {1--6},
	booktitle = {Extended Abstracts of the 2019 {CHI} Conference on Human Factors in Computing Systems  - {CHI} {EA} '19},
	publisher = {{ACM} Press},
	author = {Corno, Fulvio and De Russis, Luigi and Sáenz, Juan Pablo},
	urldate = {2020-01-05},
	date = {2019},
	langid = {english}
}

@article{berquedave_teaching_2001,
	title = {Teaching theory of computation using pen-based computers and an electronic whiteboard},
	url = {https://dl.acm.org/doi/abs/10.1145/507758.377680},
	abstract = {This paper describes a Theory of Computation course that was taught in an electronic classroom equipped with a network of pen-based computers, a touch-sensitive electronic whiteboard, and locally w...},
	journaltitle = {{ACM} {SIGCSE} Bulletin},
	author = {{BerqueDave} and K, {JohnsonDavid} and {JovanovicLarry}},
	urldate = {2020-01-05},
	date = {2001-06-25},
	file = {Snapshot:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\3G396SVI\\507758.html:text/html}
}

@article{thomas_jupyter_2016,
	title = {Jupyter Notebooks \&ndash; a publishing format for reproducible computational workflows},
	rights = {©2016 \&copy; The authors and {IOS} Press.},
	issn = {0000-0000},
	url = {https://www.medra.org/servlet/aliasResolver?alias=iospressISBN&isbn=978-1-61499-648-4&spage=87&doi=10.3233/978-1-61499-649-1-87},
	doi = {10.3233/978-1-61499-649-1-87},
	abstract = {It is increasingly necessary for researchers in all fields to write computer code, and in order to reproduce research results, it is important that this code is published. We present Jupyter notebooks, a document format for publishing code, results and explanations in a form that is both readable and executable. We discuss various tools and use cases for notebook documents.},
	pages = {87--90},
	journaltitle = {Stand Alone},
	author = {Thomas, Kluyver and Benjamin, Ragan-Kelley and Fernando, P{\textbackslash}\&eacute;rez and Brian, Granger and Matthias, Bussonnier and Jonathan, Frederic and Kyle, Kelley and Jessica, Hamrick and Jason, Grout and Sylvain, Corlay and Paul, Ivanov and Dami{\textbackslash}\&aacute;n, Avila and Safia, Abdalla and Carol, Willing and Team, Jupyter Development},
	urldate = {2020-01-05},
	date = {2016},
	langid = {english},
	file = {Thomas et al. - 2016 - Jupyter Notebooks &ndash\; a publishing format for .pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\DDDJKSQA\\Thomas et al. - 2016 - Jupyter Notebooks &ndash\; a publishing format for .pdf:application/pdf}
}

@article{wing_research_nodate,
	title = {Research Notebook: Computational Thinking--What and Why?},
	pages = {8},
	author = {Wing, Jeannette M},
	langid = {english},
	file = {Wing - Research Notebook Computational Thinking--What an.pdf:C\:\\Users\\Vartika Agrahari\\Zotero\\storage\\Y9L7CH6M\\Wing - Research Notebook Computational Thinking--What an.pdf:application/pdf}
}